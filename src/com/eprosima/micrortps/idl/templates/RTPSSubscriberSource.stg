// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "Publisher.cpp"], description=["This file contains the implementation of the publisher functions."])$

#include "$ctx.filename$.h"

#include <stdio.h>
#include <string.h>

$definitions; separator="\n"$

>>

module(ctx, parent, module, definition_list) ::= <<
$definition_list$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$

>>

annotation(ctx, annotation) ::= <<>>

interface(ctx, parent, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$

>>

exception(ctx, parent, exception) ::= <<>>

operation(ctx, parent, operation, param_list) ::= <<>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, parent, const) ::= <<>>

typedef_decl(ctx, parent, typedefs) ::= <<>>

struct_type(ctx, parent, struct) ::= <<
const uint8_t $struct.name$_id = 0x01;

const char* topic_xml = "<dds><topic>$if(ctx.lastStructure.typeCode.hasKey)$<kind>WITH_KEY</kind>$endif$<name>$ctx.filename$PubSubTopic</name><dataType>$struct.name$</dataType></topic></dds>";
const char* subscriber_xml = "<subscriber name=\"MySubscriber\"";
const char* datareader_xml = "<profiles><subscriber profile_name=\"default_xrce_subscriber_profile\"><topic><kind>$if(ctx.lastStructure.typeCode.hasKey)$WITH_KEY$else$NO_KEY$endif$</kind><name>$ctx.filename$PubSubTopic</name><dataType>$struct.name$</dataType><historyQos><kind>KEEP_LAST</kind><depth>5</depth></historyQos><durability><kind>TRANSIENT_LOCAL</kind></durability></topic></subscriber></profiles>";

void check_and_print_error(Session* session)
{
    if (session->last_status_received)
    {
        if (session->last_status.status != STATUS_OK)
        {
            printf("%sStatus error%s\n", "\x1B[1;31m", "\x1B[0m");
        }
    }
    else
    {
        printf("%sConnection error%s\n", "\x1B[1;31m", "\x1B[0m");
    }
}

void on_topic(ObjectId id, MicroBuffer* serialized_topic, void* args)
{
    if ($struct.name$_id == id.data[0])
    {
        $struct.name$ topic;
        deserialize_$struct.name$_topic(serialized_topic, &topic);

        printf("Received topic");
    }
}

int main(int argc, char** argv)
{
    /* Init session. */
    Session my_session;
    ClientKey key = {{0xAA, 0xBB, 0xCC, 0xDD}};
    uint8_t ip[4] = {{127, 0, 0, 1}};
    uint16_t port = 2019;
    if (!new_udp_session(&my_session, 0x01, key, ip, port, on_topic, NULL))
    {
        return 1;
    }

    init_session_syn(&my_session);
    check_and_print_error(&my_session);

    /* Init XRCE object. */
    ObjectId participant_id = {{0x00, OBJK_PARTICIPANT}};
    create_participant_sync_by_ref(&my_session, participant_id, "default_participant", false, false);
    check_and_print_error(&my_session);

    ObjectId topic_id = {{0x00, OBJK_TOPIC}};
    create_topic_sync_by_xml(&my_session, topic_id, topic_xml, participant_id, false, false);
    check_and_print_error(&my_session);

    ObjectId subscriber_id = {{$struct.name$_id, OBJK_SUBSCRIBER}};
    create_subscriber_sync_by_xml(&my_session, subscriber_id, subscriber_xml, participant_id, false, false);
    check_and_print_error(&my_session);

    ObjectId datareader_id = {{$struct.name$_id, OBJK_DATAREADER}};
    create_subscriber_sync_by_xml(&my_session, datareader_id, datareader_xml, subscriber_id, false, false);
    check_and_print_error(&my_session);
    
    /* Main loop. */
    while (true)
    {
        /* Request data. */
        read_data_sync(&my_session, datareader_id);
        check_and_print_error(&my_session);

        run_communication(&my_session);

        sleep(1);
    }
    
    close_session(&my_session);
    
    return 0;
}

>>

union_type(ctx, parent, union) ::= <<>>

enum_type(ctx, parent, enum) ::= <<>>
