// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

group ProtocolHeader;

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "Publisher.cpp"], description=["This file contains the implementation of the publisher functions."])$

#include "$ctx.filename$.h"

#include <stdio.h>
#include <string.h>

$definitions; separator="\n"$
>>

module(ctx, parent, module, definition_list) ::= <<
$definition_list$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$

>>

annotation(ctx, annotation) ::= <<>>

interface(ctx, parent, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$

>>

exception(ctx, parent, exception) ::= <<>>

operation(ctx, parent, operation, param_list) ::= <<>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, parent, const) ::= <<>>

typedef_decl(ctx, parent, typedefs) ::= <<>>

struct_type(ctx, parent, struct) ::= <<
const uint8_t $struct.name$_id = 0x01;

const char* topic_xml = "<dds><topic>$if(ctx.lastStructure.typeCode.hasKey)$<kind>WITH_KEY</kind>$endif$<name>$ctx.filename$PubSubTopic</name><dataType>$struct.name$</dataType></topic></dds>";
const char* publisher_xml = "<publisher name=\"MyPublisher\"";
const char* datawriter_xml = "<profiles><publisher profile_name=\"default_xrce_publisher_profile\"><topic><kind>$if(ctx.lastStructure.typeCode.hasKey)$WITH_KEY$else$NO_KEY$endif$</kind><name>$ctx.filename$PubSubTopic</name><dataType>$struct.name$</dataType><historyQos><kind>KEEP_LAST</kind><depth>5</depth></historyQos><durability><kind>TRANSIENT_LOCAL</kind></durability></topic></publisher></profiles>";

void check_and_print_error(Session* session)
{
    if (session->last_status_received)
    {
        if (session->last_status.status != STATUS_OK)
        {
            printf("%sStatus error%s\n", "\x1B[1;31m", "\x1B[0m");
        }
    }
    else
    {
        printf("%sConnection error%s\n", "\x1B[1;31m", "\x1B[0m");
    }
}

void on_topic(ObjectId id, MicroBuffer* serialized_topic, void* args)
{
    if ($struct.name$_id == id.data[0])
    {
        $struct.name$ topic;
        deserialize_$struct.name$_topic(serialized_topic, &topic);

        printf("Received topic");
    }
}

int main(int argc, char** argv)
{
    /* Init session. */
    Session my_session;
    ClientKey key = {{0x11, 0x22, 0x33, 0x44}};
    uint8_t ip[4] = {{127, 0, 0, 1}};
    uint16_t port = 2019;
    if (!new_udp_session(&my_session, 0x01, key, ip, port, on_topic, NULL))
    {
        return 1;
    }

    init_session_syn(&my_session);
    check_and_print_error(&my_session);

    /* Init XRCE object. */
    ObjectId participant_id = {{0x00, OBJK_PARTICIPANT}};
    create_participant_sync_by_ref(&my_session, participant_id, "default_participant", false, false);
    check_and_print_error(&my_session);

    ObjectId topic_id = {{0x00, OBJK_TOPIC}};
    create_topic_sync_by_xml(&my_session, topic_id, topic_xml, participant_id, false, false);
    check_and_print_error(&my_session);

    ObjectId publisher_id = {{$struct.name$_id, OBJK_PUBLISHER}};
    create_publisher_sync_by_xml(&my_session, publisher_id, publisher_xml, participant_id, false, false);
    check_and_print_error(&my_session);

    ObjectId datawriter_id = {{$struct.name$_id, OBJK_DATAWRITER}};
    create_publisher_sync_by_xml(&my_session, datawriter_id, datawriter_xml, publisher_id, false, false);
    check_and_print_error(&my_session);
    
    /* Main loop. */
    while (true)
    {
        /* Write $struct.name$ topic. */
        OutputReliableStream* reliable_stream = &my_session.output_reliable_stream;

        $struct.name$ topic = {0};
        uint32_t topic_size = size_of_$struct.name$_topic(&topic, 0);
        MicroBuffer* topic_buffer = prepare_reliable_stream_for_topic(reliable_stream, datawriter_id, topic_size);
        if (topic_buffer != NULL)
        {
            serialize_$struct.name$_topic(topic_buffer, &topic);
            printf("Sent topic\n");
        }

        run_communication(&my_session);

        sleep(1);
    }
    
    close_session(&my_session);
    
    return 0;
}
>>


union_type(ctx, parent, union) ::= <<>>

enum_type(ctx, parent, enum) ::= <<>>
